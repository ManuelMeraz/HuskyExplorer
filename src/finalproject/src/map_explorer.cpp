#include <ros/ros.h>
#include <random_numbers/random_numbers.h>
#include <angles/angles.h>
#include <tf/transform_datatypes.h>
#include <nav_msgs/Odometry.h>
#include <nav_msgs/OccupancyGrid.h>
#include <map_msgs/OccupancyGridUpdate.h>
#include <sensor_msgs/LaserScan.h>
#include <geometry_msgs/Pose.h>
#include <geometry_msgs/Point.h>
#include <geometry_msgs/Twist.h>
#include <geometry_msgs/PoseWithCovarianceStamped.h>
#include <occupancy_grid_utils/shortest_path.h>
#include <occupancy_grid_utils/coordinate_conversions.h>
#include <boost/optional.hpp>
#include <vector>

namespace utils = occupancy_grid_utils;

nav_msgs::Odometry ekf_pose;
geometry_msgs::PoseWithCovarianceStamped amcl_pose;
random_numbers::RandomNumberGenerator* rng;
nav_msgs::OccupancyGrid map;

// These 2 store the results of A* calculations
utils::AStarResult path;

// Stores coodinates of path in map frame
std::vector<geometry_msgs::Point> point_path;

// Program waits for map to be published to /map
bool map_initialized = false;

// Robot completed it's A* path
// Also set to true when path interrupted by 
// obstacle avoidance
bool path_complete = true;

// Program runs at the pace of new poses
// being generated by amcl
bool new_pose = false;

// True if laser range data produces
// data < 0.75m
bool obstacle_detected = true;

// In the process of rotating to turn away
// from an obstacle the robot ran into
bool avoiding_obstacle = false;

// True when rotating counter-clockwise,
// otherwise robot is turning clockwise
bool turn_direction = true;

// Index value robot is currently at following
// the path within point_path
int path_index = 0;

// Calculate goal location for path
geometry_msgs::Point calculate_goal(bool ,double ,float);

// Get heading of robot as yaw 
double get_current_heading();

void ekf_callback(const nav_msgs::Odometry &msg);
void amcl_callback(const geometry_msgs::PoseWithCovarianceStamped &msg);
void map_callback(const nav_msgs::OccupancyGrid &msg);
void map_update_callback(const map_msgs::OccupancyGridUpdate &msg);
void scan_callback(const sensor_msgs::LaserScan &msg);

ros::Publisher cmd_pub;

int main(int argc, char **argv) {
    ros::init(argc, argv, "averagefilter");
    ros::NodeHandle nh;

    ros::Subscriber ekf_sub = nh.subscribe("/odometry/filtered", 1000, &ekf_callback);
    ros::Subscriber map_sub = nh.subscribe("/move_base/global_costmap/costmap", 1000, &map_callback);
    ros::Subscriber map_update_sub = nh.subscribe("/move_base/global_costmap/costmap_updates", 1000, &map_update_callback);
    ros::Subscriber amcl_sub = nh.subscribe("/amcl_pose", 1000, &amcl_callback);
    ros::Subscriber scan_sub = nh.subscribe("/scan", 1000, &scan_callback);
    cmd_pub = nh.advertise<geometry_msgs::Twist>("/cmd_vel", 1000);

    while(ros::ok()) {
        // Spin first to acquire map
        ros::spinOnce();

        // Map still not acquired
        if(!map_initialized) {
            ros::Duration(1).sleep();
            continue;
        }

        if (map_initialized && !obstacle_detected) {

            if(path_complete && new_pose) {
                // New path will be set, let robot know
                path_complete = false;

                // The goal location of the robot
                geometry_msgs::Point to;

                // Number of attempts for goal at given distance
                int num_attempts = 0;

                // If path is failed at current distance
                // Scale down distance by 90% and try again
                float scale_distance = 0.9;

                // If all attempts failed, then move forward
                bool all_paths_failed = false;

                // Distance of random goal location
                float distance = 8.5;

                do {
                    num_attempts++;

                    // Get goal 
                    to = calculate_goal(avoiding_obstacle, get_current_heading(), distance);
                    
                    if(num_attempts == 100) {
                        ROS_INFO_STREAM("Decreasing distance goal...");
                        ROS_INFO_STREAM("Distance: " << distance);
                        num_attempts = 0;
                        distance *= scale_distance;
                    }

                    if(distance < 3.0) {
                        ROS_INFO_STREAM("All paths failed!");
                        all_paths_failed = true;
                        break;
                    }

                // Goal point is free
                } while(map.data[utils::cellIndex(map.info,utils::pointCell(map.info,to))] != 0);

                // If previously avoiding obstacle, reset
                avoiding_obstacle = false;

                // If valid goal is found
                if(!all_paths_failed) {

                    geometry_msgs::Point from;
                    from.x = amcl_pose.pose.pose.position.x;
                    from.y = amcl_pose.pose.pose.position.y;

                    // Convert path start and goal point grid cells for map
                    utils::Cell fromCell = utils::pointCell(map.info, from);
                    utils::Cell toCell = utils::pointCell(map.info, to);

                    // Generate path of of grid cells
                    boost::optional<utils::AStarResult> possible_path = 
                        utils::shortestPathAStar(map, fromCell, toCell);

                    // If path was generated
                    if(possible_path.is_initialized()) {
                        ROS_INFO_STREAM("Path Success!");
                        path = possible_path.get();

                        int size = path.first.size();
                        for(int i = 0; i < size; i++) {
                            point_path.push_back(utils::cellCenter(map.info, path.first[i]));
                        }

                    // If A* failed to produce path
                    } else {
                        ROS_INFO_STREAM("Path Failed!");

                        // Move forward 
                        geometry_msgs::Twist drive_command;
                        drive_command.linear.x = 0.2;
                        cmd_pub.publish(drive_command);

                        // Reset to attempt new path calculation
                        path_complete = true;
                        path_index = 0;
                        point_path.clear();
                    }
                } else {

                    // If no valid goal location was caluclated
                    ROS_INFO_STREAM("Moving forward...");
                    geometry_msgs::Twist drive_command;
                    drive_command.linear.x = 0.2;
                    cmd_pub.publish(drive_command);

                    // Reset all flags to generate new path at new location
                    path_complete = true;
                    path_index = 0;
                    point_path.clear();
                }

            } else {
                int size = point_path.size();

                // Still on the same path
                while(path_index < size) {
                    // Next vertix in path
                    geometry_msgs::Point vertix = point_path[path_index];

                    // Ignore all points in path that are too close to the robot
                    if(hypot(amcl_pose.pose.pose.position.x - vertix.x,
                                amcl_pose.pose.pose.position.y - vertix.y) > 0.3) {

                        // Straight line heading to next point
                        double goal_heading = atan2(vertix.y - amcl_pose.pose.pose.position.y, 
                                vertix.x - amcl_pose.pose.pose.position.x);

                        // Get current heading of robot
                        tf::Quaternion q(
                                amcl_pose.pose.pose.orientation.x,
                                amcl_pose.pose.pose.orientation.y,
                                amcl_pose.pose.pose.orientation.z,
                                amcl_pose.pose.pose.orientation.w);

                        tf::Matrix3x3 m(q);
                        double roll, pitch, current_heading;
                        m.getRPY(roll, pitch, current_heading);

                        geometry_msgs::Twist drive_command;

                        // Calculate the difference from the goal heading to current heading
                        double heading_diff = angles::shortest_angular_distance(current_heading, goal_heading);

                        // If turned too far away from next vertix
                        if (fabs(heading_diff) > 0.4) {

                            // If positive
                            if(heading_diff > 0) {
                                // Turn counter clockwise
                                drive_command.angular.z = 0.5;
                            } else {

                                // Negative, then turn clockwise
                                drive_command.angular.z = -0.5;
                            }
                        } else {

                            // Move forward, vertix is directly ahead
                            drive_command.linear.x = 0.5;
                        }

                        cmd_pub.publish(drive_command);
                        break;

                    } else {

                        // Increment path index when distance to vertix in path 
                        // is less than 0.3m
                        path_index++;

                        // Path is complete, reached end of point path
                        if(path_index == size - 1) {
                            ROS_INFO_STREAM("Path Complete!");
                            ROS_INFO_STREAM("Distance to goal: " << hypot(amcl_pose.pose.pose.position.x - point_path[point_path.size() - 1].x,
                                        amcl_pose.pose.pose.position.y - point_path[point_path.size() - 1].y));

                            ROS_INFO_STREAM("Current Pose: X: " << amcl_pose.pose.pose.position.x << " Y: " << amcl_pose.pose.pose.position.y);

                            ROS_INFO_STREAM("Goal Pose: X: " << vertix.x << " Y: " << vertix.y);

                            path_complete = true;
                            point_path.clear();
                            path_index = 0;
                            break;
                        }

                    }
                }
            }
        }
    }
    return 0;
}


void ekf_callback(const nav_msgs::Odometry &msg) {
    ekf_pose = msg;
}

void map_callback(const nav_msgs::OccupancyGrid &msg) {

    // Only acquire map from map server once
    if(!map_initialized) {
        map = msg;
        map_initialized = true;
    }
}

void map_update_callback(const map_msgs::OccupancyGridUpdate &msg) {

    // Only update map once data is stored for it
    if(map_initialized) {
        int index = 0;

        // Iterate through array based off of grid cell coordinates
        for(int y=msg.y; y< msg.y+msg.height; y++){
            for(int x=msg.x; x< msg.x+msg.width; x++){

                // Update map
                utils::Cell gridCoord(x, y);
                int map_index = utils::cellIndex(map.info, gridCoord);

                // If not valid gridCoord, ignore
                if(map_index > -1)
                    map.data[ map_index ] = msg.data[ index++ ]; 
            }

        }
    }
}


void amcl_callback(const geometry_msgs::PoseWithCovarianceStamped &msg) {
    // Robot sends drive commands at the pace that amcl poses come in
    new_pose = true;
    amcl_pose = msg;
}

void scan_callback(const sensor_msgs::LaserScan &msg) {
    int size = msg.ranges.size();
    // Scan only the laser ranges in front of the husky
    for(int i = 0; i <= size; i++) {
        // 0.3 for false positives
        if(msg.ranges[i] > 0.3 && msg.ranges[i] < 0.75 && !isinf(msg.ranges[i])) {

            // Just starting to avoid obstacle
            if(!avoiding_obstacle) {
                ROS_INFO_STREAM("Avoiding obstacle...");
                avoiding_obstacle = true;

                // Turn direction based off of angle of laser scan
                if(i < size/2) {
                    // Turn clockwise
                    turn_direction = true;
                } else {
                    // counter clockwise
                    turn_direction = false;
                }
            }

            obstacle_detected = true;

            // Get new path
            path_complete = true;
            point_path.clear();
            path_index = 0;

            geometry_msgs::Twist drive_command;

            // Obstacle is on the right side
            if(turn_direction) {
                // turn clockwise
                drive_command.angular.z = -0.5;

            // Obstacle is on the left
            } else{
                //turn counter clockwise
                drive_command.angular.z = 0.5;
            } 

            cmd_pub.publish(drive_command);
            return;
        }
    }

    obstacle_detected = false;
}

geometry_msgs::Point calculate_goal(bool avoiding_ostacle, double current_heading, float distance) {
    // Random heading is a random direction for goal location
    // Goal heading is the sum of the random_heading and goal heading
    double random_heading, goal_heading;

    // Used to generate random headings
    rng = new random_numbers::RandomNumberGenerator();

    // Just finished avoiding an obstacle
    if(avoiding_obstacle) {

        // Generate random heading that will either point
        // to the front right quarter, or front left quarter
        random_heading = rng->uniformReal(0, M_PI/4);

        // Previously turned right to avoid
        if(turn_direction) {
            // Goal heading is in the front right
            goal_heading = current_heading - M_PI/4 - random_heading;

       // Previously turned left to avoid 
        } else {
            // Goal heading is in the front left
            goal_heading = current_heading + M_PI/4 + random_heading;
        }

    // Otherwise goal could be anywhere in front of the robot
    } else {
        random_heading = rng->uniformReal(0, M_PI);
        goal_heading = current_heading + random_heading;
    }


    geometry_msgs::Point to;

    // Calculate goal 8.5m away from robot
    to.x = amcl_pose.pose.pose.position.x + distance * cos(goal_heading);
    to.y = amcl_pose.pose.pose.position.y + distance * sin(goal_heading);

    delete rng;
    return to;
}

double get_current_heading() {
    // Transform orientation of robot  to roll, pitch, yaw
    tf::Quaternion q(
            amcl_pose.pose.pose.orientation.x,
            amcl_pose.pose.pose.orientation.y,
            amcl_pose.pose.pose.orientation.z,
            amcl_pose.pose.pose.orientation.w);

    tf::Matrix3x3 m(q);
    // current_heading is yaw of robot
    double roll, pitch, current_heading;
    m.getRPY(roll, pitch, current_heading);

    return current_heading;
}
